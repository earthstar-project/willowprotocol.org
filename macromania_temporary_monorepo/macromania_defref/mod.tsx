import { getNameAndDebug } from "../macromania_names_id/mod.tsx";
import {
  addName,
  dependencyJs,
  hrefToName,
  IdA,
  previewScopeDependencyJs,
  registerPreview,
} from "./deps.ts";
import { Expressions } from "./deps.ts";
import { hrefTo } from "./deps.ts";
import { dependencyCss } from "./deps.ts";
import { getPreviewPath } from "./deps.ts";
import { absoluteOutFsPath } from "./deps.ts";
import { previewScopeDependencyCss } from "./deps.ts";
import { PreviewScope } from "./deps.ts";
import { MData, MId } from "./deps.ts";
import { MClass } from "./deps.ts";
import { MHref } from "./deps.ts";
import { Dfn } from "./deps.ts";
import {
  A,
  AProps,
  Colors,
  Context,
  createConfigOptions,
  createLogger,
  createNamespace,
  DebuggingInformation,
  Expression,
  isMathMode,
  M,
  relative,
  ScriptDependencyInfo,
  styleDebuggingInformation,
  styleName,
  StylesheetDependencyInfo,
} from "./deps.ts";

const l = createLogger("LoggerDefref");
const ConfigMacro = l.ConfigMacro;
export { ConfigMacro as LoggerDefref };

/**
 * Configuration options for DefRef.
 */
export type DefrefConfig = {
  /**
   * An optional function for automatically constructing beginning-of-sentence versions of references.
   *
   * Defaults to rather naive capitalization without any locale-specific features.
   */
  defaultRb?: ((ctx: Context, evaledR: string) => Expression) | null;
  /**
   * An optional function for automatically constructing plural versions of references.
   */
  defaultRs?: ((ctx: Context, evaledR: string) => Expression) | null;
  /**
   * Css dependencies to add in all files that use a `<Def/>` macro.
   */
  depsCssDef?: StylesheetDependencyInfo[];
  /**
   * Js dependencies to add in all files that use a `<Def/>` macro.
   */
  depsJsDef?: ScriptDependencyInfo[];
  /**
   * Css dependencies to add in all files that use a referencing macro.
   */
  depsCssRef?: StylesheetDependencyInfo[];
  /**
   * Js dependencies to add in all files that use a referencing macro.
   */
  depsJsRef?: ScriptDependencyInfo[];
  /**
   * Css dependencies to add to all preview pages generated by a `<Def/>` macro.
   */
  depsCssPreview?: StylesheetDependencyInfo[];
  /**
   * Js dependencies to add to all preview pages generated by a `<Def/>` macro.
   */
  depsJsPreview?: ScriptDependencyInfo[];
};

const [getConfig, ConfigDefref] = createConfigOptions<
  DefrefConfig,
  DefrefConfig
>("ConfigDefref", () => ({
  defaultRb: (_ctx, evaledR) =>
    `${evaledR.charAt(0).toUpperCase()}${evaledR.slice(1)}`,
  defaultRs: null,
}), (old, update) => {
  const newValue: DefrefConfig = {
    defaultRb: update.defaultRb === undefined
      ? old.defaultRb
      : update.defaultRb,
    defaultRs: update.defaultRs === undefined
      ? old.defaultRs
      : update.defaultRs,
    depsCssDef: update.depsCssDef === undefined
      ? old.depsCssDef
      : update.depsCssDef,
    depsJsDef: update.depsJsDef === undefined
      ? old.depsJsDef
      : update.depsJsDef,
    depsCssRef: update.depsCssRef === undefined
      ? old.depsCssRef
      : update.depsCssRef,
    depsJsRef: update.depsJsRef === undefined
      ? old.depsJsRef
      : update.depsJsRef,
    depsCssPreview: update.depsCssPreview === undefined
      ? old.depsCssPreview
      : update.depsCssPreview,
    depsJsPreview: update.depsJsPreview === undefined
      ? old.depsJsPreview
      : update.depsJsPreview,
  };

  return newValue;
});
export { ConfigDefref };

const defs = createNamespace<DefInfo>("Defref Defs");

/**
 * The information to associate with each def.
 */
type DefInfo = {
  r?: Expression;
  rb?: Expression;
  rs?: Expression;
  rsb?: Expression;
  ensureMath: boolean;
  math?: Expressions;
  refClass?: Expression[] | Expression;
  refData?: Record<string, Expression>;
  numbering?: NumberingProps;
  noPreview?: boolean;
  noHighlight?: boolean;
  href?: Expression;
  noTooltipOnDefHover?: boolean;
};

function defInfoR(info: DefInfo, name: string): Expression {
  return info.r ?? name;
}

function defInfoRb(info: DefInfo, name: string): Expression {
  if (info.rb) {
    return info.rb;
  }

  return (
    <map
      fun={(evaled, ctx) => {
        const config = getConfig(ctx);

        if (config.defaultRb! === null) {
          l.warn(
            ctx,
            `Tried to reference a name with the ${
              Colors.yellow(`<Rb/>`)
            } macro, but no such formatting was registered.`,
          );
          l.logGroup(ctx, () => {
            l.warn(ctx, `Name: ${styleName(name)}`);
            l.warn(
              ctx,
              `Defined at ${
                styleDebuggingInformation(getNameAndDebug(ctx, name)![1])
              }`,
            );
          });
          l.at(ctx);
          return name;
        } else {
          return config.defaultRb!(ctx, evaled);
        }
      }}
    >
      {defInfoR(info, name)}
    </map>
  );
}

function defInfoRs(info: DefInfo, name: string): Expression {
  if (info.rs) {
    return info.rs;
  }

  return (
    <map
      fun={(evaled, ctx) => {
        const config = getConfig(ctx);

        if (config.defaultRs! === null) {
          l.warn(
            ctx,
            `Tried to reference a name with the ${
              Colors.yellow(`<Rs/>`)
            } macro, but no such formatting was registered.`,
          );
          l.logGroup(ctx, () => {
            l.warn(ctx, `Name: ${styleName(name)}`);
            l.warn(
              ctx,
              `Defined at ${
                styleDebuggingInformation(getNameAndDebug(ctx, name)![1])
              }`,
            );
          });
          l.at(ctx);
          return name;
        } else {
          return config.defaultRs!(ctx, evaled);
        }
      }}
    >
      {defInfoR(info, name)}
    </map>
  );
}

function defInfoRsb(info: DefInfo, name: string): Expression {
  if (info.rsb) {
    return info.rsb;
  } else if (info.rs) {
    return (
      <map
        fun={(evaled, ctx) => {
          const config = getConfig(ctx);

          if (config.defaultRb! === null) {
            l.warn(
              ctx,
              `Tried to reference a name with the ${
                Colors.yellow(`<Rsb/>`)
              } macro, but no such formatting was registered or could be derived.`,
            );
            l.logGroup(ctx, () => {
              l.warn(ctx, `Name: ${styleName(name)}`);
              l.warn(
                ctx,
                `Defined at ${
                  styleDebuggingInformation(getNameAndDebug(ctx, name)![1])
                }`,
              );
            });
            l.at(ctx);
            return name;
          } else {
            return config.defaultRb!(ctx, evaled);
          }
        }}
      >
        {info.rs}
      </map>
    );
  } else if (info.rb) {
    return (
      <map
        fun={(evaled, ctx) => {
          const config = getConfig(ctx);

          if (config.defaultRs! === null) {
            l.warn(
              ctx,
              `Tried to reference a name with the ${
                Colors.yellow(`<Rsb/>`)
              } macro, but no such formatting was registered or could be derived.`,
            );
            l.logGroup(ctx, () => {
              l.warn(ctx, `Name: ${styleName(name)}`);
              l.warn(
                ctx,
                `Defined at ${
                  styleDebuggingInformation(getNameAndDebug(ctx, name)![1])
                }`,
              );
            });
            l.at(ctx);
            return name;
          } else {
            return config.defaultRs!(ctx, evaled);
          }
        }}
      >
        {info.rb}
      </map>
    );
  } else {
    return (
      <map
        fun={(evaled, ctx) => {
          const config = getConfig(ctx);

          if (config.defaultRs! === null || config.defaultRb === null) {
            l.warn(
              ctx,
              `Tried to reference a name with the ${
                Colors.yellow(`<Rsb/>`)
              } macro, but no such formatting was registered or could be derived.`,
            );
            l.logGroup(ctx, () => {
              l.warn(ctx, `Name: ${styleName(name)}`);
              l.warn(
                ctx,
                `Defined at ${
                  styleDebuggingInformation(getNameAndDebug(ctx, name)![1])
                }`,
              );
            });
            l.at(ctx);
            return name;
          } else {
            return (
              <map
                fun={(evaled, ctx) => {
                  return config.defaultRb!(ctx, evaled);
                }}
              >
                {config.defaultRs!(ctx, evaled)}
              </map>
            );
          }
        }}
      >
        {defInfoR(info, name)}
      </map>
    );
  }
}

export type DefProps = {
  /**
   * The name by which to reference this def.
   *
   * Provides the default value for the `r` prop.
   */
  n: string;
  /**
   * The html tag to wrap the definition in. Defaults to `<Dfn>`.
   */
  defTag?: (inner: Expression, id: Expression) => Expression;
  /**
   * Set to true to *not* wrap the children in an a tag.
   */
  noLink?: boolean;
  /**
   * The Expression to which the `<R/>` macro should expand for this def.
   *
   * Defaults to `n`.
   */
  r?: Expression;
  /**
   * The Expression to which the `<Rb/>` macro should expand for this def.
   */
  rb?: Expression;
  /**
   * The Expression to which the `<Rs/>` macro should expand for this def.
   */
  rs?: Expression;
  /**
   * The Expression to which the `<Rsb/>` macro should expand for this def.
   */
  rsb?: Expression;
  /**
   * HTML classes to apply to the `<a>` tag of the definition.
   */
  defClass?: Expression[] | Expression;
  /**
   * HTML classes to apply to the `<a>` tag of all refs.
   */
  refClass?: Expression[] | Expression;
  /**
   * HTML data attributes to apply to the `<a>` tag of the definition.
   */
  defData?: Record<string, Expression>;
  /**
   * HTML data attributes to apply to the `<a>` tag of all refs.
   */
  refData?: Record<string, Expression>;
  /**
   * The Expressions to which the `<R/>` macro should expand when in math mode.
   *
   * Has no effect on any references but the `<R/>` macro.
   */
  math?: Expressions;
  /**
   * Numbering information for the `<Rc/>` and `<Rcb/>` macros.
   */
  numbering?: NumberingProps;
  /**
   * Set this to true to *not* create a preview.
   */
  noPreview?: boolean;
  /**
   * Set this to true to not *display* a preview tooltip when hovering over the *definition* itself.
   */
  noTooltipOnDefHover?: boolean;
  /**
   * Set this to true to *not* highlight definitions and references to hover, even if there is a preview.
   * When `noPreview` is set to true, then no highlighting occurs anyways.
   */
  noHighlight?: boolean;
  /**
   * A preview for this definition. If this is set, then the containing preview
   * scope (if any) will ignore this definition, and the explicit preview is used instead.
   */
  preview?: Expression;
  /**
   * When set, does not actually bind the name. Renders the same output, but modifies no macro state.
   */
  fake?: boolean;
  /**
   * Give the definition and all references a `data-preview-wide` attribute.
   */
  wide?: boolean;
  /**
   * Instead of linking to the definition site itself, have the def and its references link elsewhere.
   */
  href?: Expression;
  /**
   * The display text of the definition.
   *
   * Defaults to `r`.
   */
  children?: Expressions;
};

/**
 * Information on how to render numbered references to a category of defs.
 */
export type NumberingInfo = {
  /**
   * How to render the category for the `<Rc/>` macro.
   */
  r: Expression;
  /**
   * How to render the category for the `<Rcb/>` macro.
   */
  rb: Expression;
  /**
   * How to render the plural of the category for the `<Rc/>` macro.
   */
  rs: Expression;
  /**
   * How to render the plural of the category for the `<Rc/>` macro.
   */
  rsb: Expression;
  /**
   * How to render a given numbering.
   */
  render: (ctx: Context, numbering: number[]) => Expression;
};

/**
 * Numbering information for the `<Rc/>` and `<Rcb/>` macros.
 */
export type NumberingProps = {
  /**
   * The numbering of this definition.
   */
  numbering: number[];
  /**
   * Information on how to render numbered references to this definition.
   */
  info: NumberingInfo;
};

export function Def(props: DefProps): Expression {
  return (
    <impure
      fun={(ctx) => {
        if (!props.fake) {
          addName(ctx, props.n);
        }

        const refData = props.refData ?? {};
        if (props.wide) {
          refData["preview-class"] = "wide";
        }

        const info: DefInfo = {
          r: props.r,
          rb: props.rb,
          rs: props.rs,
          rsb: props.rsb,
          refClass: props.refClass,
          refData,
          ensureMath: isMathMode(ctx),
          math: props.math,
          numbering: props.numbering,
          noPreview: props.noPreview,
          noHighlight: props.noHighlight,
          href: props.href,
          noTooltipOnDefHover: props.noTooltipOnDefHover,
        };

        if (!props.fake) {
          defs.addName(ctx, props.n, info);
        }

        const config = getConfig(ctx);

        for (const dep of config.depsCssDef ?? []) {
          dependencyCss(ctx, dep);
        }

        for (const dep of config.depsJsDef ?? []) {
          dependencyJs(ctx, dep);
        }

        const defData = props.defData ?? {};
        if (props.wide) {
          defData["preview-class"] = "wide";
        }

        const tag = linkTag({
          ctx,
          isRef: false,
          name: props.n,
          info,
          mode: "r",
          classes: props.defClass,
          data: defData,
          children: props.children,
          queryParams: [],
          noLink: props.noLink,
        });

        if (isMathMode(ctx) && props.math) {
          l.warn(
            ctx,
            `Specifying the ${Colors.yellow(`math`)} prop of a ${
              Colors.yellow(`<Def>`)
            } macro inside a ${Colors.yellow(`<M>`)} or ${
              Colors.yellow(`<MM>`)
            } macro has no effect.`,
          );
          l.logGroup(ctx, () => {
            l.warn(ctx, `Name: ${styleName(props.n)}`);
          });
          l.at(ctx);
        }

        let explicitPreviewExp: Expression = "";

        // Register preview.
        if (!props.noPreview && !props.fake) {
          if (props.preview === undefined) {
            registerPreview(ctx, {
              name: props.n,
            });
            addScopeDeps(ctx);
          } else {
            explicitPreviewExp = (
              <omnomnom>
                <PreviewScope>
                  {props.preview}
                  <impure
                    fun={(ctx) => {
                      registerPreview(ctx, {
                        name: props.n,
                      }, true);
                      addScopeDeps(ctx);
                      return "";
                    }}
                  />
                </PreviewScope>
              </omnomnom>
            );
          }
        }

        if (tag === null) {
          return null;
        } else if (isMathMode(ctx)) {
          return (
            <>
              <MId id={props.n}>{tag}</MId>
              {explicitPreviewExp}
            </>
          );
        } else {
          const id = props.n;
          if (props.defTag) {
            return <>{props.defTag(tag, id)}{explicitPreviewExp}</>;
          } else {
            return (
              <>
                <Dfn id={id}>
                  {tag}
                </Dfn>
                {explicitPreviewExp}
              </>
            );
          }
        }
      }}
    />
  );
}

/**
 * Add css and js dependencies to the current scope that are common to all preview pages.
 */
function addScopeDeps(ctx: Context) {
  const config = getConfig(ctx);

  for (const dep of config.depsCssPreview ?? []) {
    previewScopeDependencyCss(ctx, dep, true);
  }

  for (const dep of config.depsJsPreview ?? []) {
    previewScopeDependencyJs(ctx, dep, true);
  }
}

export type ReferenceProps = {
  /**
   * The name to reference.
   */
  n: string;
  /**
   * Query parameters to append to the url of the reference.
   */
  queryParams?: [string, string][];
  /**
   * A different id to use in the url of the reference than the one registered at the definition.
   */
  replacementId?: string;
  /**
   * Additional data attributes to add to this reference.
   */
  extraData?: Record<string, Expression>;
  /**
   * If true, do not show a preview when hovering over the reference.
   */
  noPreview?: boolean;
  /**
   * The rendered body of the reference, overwriting the default one.
   */
  children?: Expressions;
};

export function R(
  { n, children, queryParams = [], replacementId, noPreview, extraData }:
    ReferenceProps,
): Expression {
  return (
    <impure
      fun={(ctx) => {
        const info = defs.getName(ctx, n);
        return linkTag({
          ctx,
          isRef: true,
          name: n,
          info,
          mode: "r",
          children: children,
          queryParams,
          replacementId,
          noPreview,
          extraData,
        });
      }}
    />
  );
}

export function Rb(
  { n, children, queryParams = [], replacementId, noPreview, extraData }:
    ReferenceProps,
): Expression {
  return (
    <impure
      fun={(ctx) => {
        const info = defs.getName(ctx, n);
        return linkTag({
          ctx,
          isRef: true,
          name: n,
          info,
          mode: "rb",
          children: children,
          queryParams,
          replacementId,
          noPreview,
          extraData,
        });
      }}
    />
  );
}

export function Rs(
  { n, children, queryParams = [], replacementId, noPreview, extraData }:
    ReferenceProps,
): Expression {
  return (
    <impure
      fun={(ctx) => {
        const info = defs.getName(ctx, n);
        return linkTag({
          ctx,
          isRef: true,
          name: n,
          info,
          mode: "rs",
          children: children,
          queryParams,
          replacementId,
          noPreview,
          extraData,
        });
      }}
    />
  );
}

export function Rsb(
  { n, children, queryParams = [], replacementId, noPreview, extraData }:
    ReferenceProps,
): Expression {
  return (
    <impure
      fun={(ctx) => {
        const info = defs.getName(ctx, n);
        return linkTag({
          ctx,
          isRef: true,
          name: n,
          info,
          mode: "rsb",
          children: children,
          queryParams,
          replacementId,
          noPreview,
          extraData,
        });
      }}
    />
  );
}

export function Rc(
  {
    n,
    children,
    queryParams = [],
    replacementId,
    noPreview,
    extraData,
    render,
  }:
    & ReferenceProps
    & { render?: (ctx: Context, numbering: number[]) => Expression },
): Expression {
  return (
    <impure
      fun={(ctx) => {
        const info = defs.getName(ctx, n);
        return linkTag({
          ctx,
          isRef: true,
          name: n,
          info,
          mode: "rc",
          render,
          children: children,
          queryParams,
          replacementId,
          noPreview,
          extraData,
        });
      }}
    />
  );
}

export function Rcb(
  {
    n,
    children,
    queryParams = [],
    replacementId,
    noPreview,
    extraData,
    render,
  }:
    & ReferenceProps
    & { render?: (ctx: Context, numbering: number[]) => Expression },
): Expression {
  return (
    <impure
      fun={(ctx) => {
        const info = defs.getName(ctx, n);
        return linkTag({
          ctx,
          isRef: true,
          name: n,
          info,
          mode: "rcb",
          render,
          children: children,
          queryParams,
          replacementId,
          noPreview,
          extraData,
        });
      }}
    />
  );
}

function linkTag(opts: {
  ctx: Context;
  isRef: boolean;
  name: string;
  info: DefInfo | undefined;
  mode: "r" | "rb" | "rs" | "rsb" | "rc" | "rcb";
  children?: Expressions;
  classes?: Expression[] | Expression;
  data?: Record<string, Expression>;
  render?: (ctx: Context, numbering: number[]) => Expression;
  queryParams: [string, string][];
  replacementId?: string;
  noPreview?: boolean;
  extraData?: Record<string, Expression>;
  noLink?: boolean;
}): Expression | null {
  // Add dependencies that are required on all pages that contain any refs.
  const config = getConfig(opts.ctx);

  for (const dep of config.depsCssRef ?? []) {
    previewScopeDependencyCss(opts.ctx, dep, true);
  }

  for (const dep of config.depsJsRef ?? []) {
    previewScopeDependencyJs(opts.ctx, dep, true);
  }

  if (opts.info === undefined) {
    if (opts.ctx.mustMakeProgress()) {
      l.warn(
        opts.ctx,
        `Could not resolve name ${
          styleName(opts.name)
        }, creating an invalid link.`,
      );
      l.at(opts.ctx);

      if (isMathMode(opts.ctx)) {
        return mathLink({
          url: "#",
          children: "invalid-reference",
        });
      } else {
        return <A href="#">invalid-reference</A>;
      }
    } else {
      return null;
    }
  }

  let exps: Expressions;
  if (opts.info.math && ((opts.info.ensureMath) || isMathMode(opts.ctx))) {
    exps = opts.info.math;
  } else if (opts.mode === "r") {
    exps = defInfoR(opts.info!, opts.name);
  } else if (opts.mode === "rb") {
    exps = defInfoRb(opts.info!, opts.name);
  } else if (opts.mode === "rs") {
    exps = defInfoRs(opts.info!, opts.name);
  } else if (opts.mode === "rsb") {
    exps = defInfoRsb(opts.info!, opts.name);
  } else {
    if (opts.info.numbering === undefined) {
      l.error(
        opts.ctx,
        `Cannot create a numbered reference to a ${
          Colors.yellow(`<Def/>`)
        } without ${Colors.yellow(`numbering`)} information.`,
      );
      l.logGroup(opts.ctx, () => {
        l.error(opts.ctx, `Name: ${styleName(opts.name)}`);
        l.error(
          opts.ctx,
          `Defined at ${
            styleDebuggingInformation(getNameAndDebug(opts.ctx, opts.name)![1])
          }`,
        );
      });
      return opts.ctx.halt();
    }

    const render = opts.render ?? opts.info.numbering.info.render;

    exps = opts.children
      ? [
        <exps x={opts.children} />,
        " ",
        render(opts.ctx, opts.info.numbering.numbering),
      ]
      : [
        opts.mode === "rc"
          ? opts.info.numbering.info.r
          : opts.info.numbering.info.rb,
        "&nbsp;",
        render(opts.ctx, opts.info.numbering.numbering),
      ];
  }

  let data: Record<string, Expression> = {};
  if (opts.isRef) {
    if (opts.info.refData !== undefined) {
      data = { ...opts.info.refData };
    }
  }
  addDataAttributes(
    opts.ctx,
    data!,
    opts.name,
    true,
    !(opts.info.noPreview || opts.noPreview) &&
      (!(opts.info.noTooltipOnDefHover && !opts.isRef)),
    !opts.info.noHighlight,
    opts.queryParams,
    opts.replacementId,
    opts.extraData,
  );

  for (const key in opts.data) {
    data[key] = opts.data[key];
  }

  const refClass = opts.isRef ? opts.info.refClass : undefined;
  const clazz = opts.classes ?? refClass;
  const finalData = data;
  if (isMathMode(opts.ctx)) {
    if (opts.info.math && !opts.info.ensureMath) {
      exps = opts.info.math;
    }
  }
  const children = opts.children && opts.mode != "rc" && opts.mode != "rcb"
    ? opts.children
    : <exps x={exps} />;

  if (isMathMode(opts.ctx) || opts.info.ensureMath) {
    const href = opts.info.href
      ? opts.info.href
      : hrefToName(opts.ctx, opts.name, opts.replacementId);

    if (href === null) {
      if (opts.ctx.mustMakeProgress()) {
        l.warn(
          opts.ctx,
          `Could not resolve name ${
            styleName(opts.name)
          }, creating an invalid link.`,
        );
        l.at(opts.ctx);
        return mathLink({
          url: "#",
          clazz,
          data: finalData,
          children,
          ensureMath: opts.info.ensureMath,
          noLink: opts.noLink,
        });
      } else {
        return null;
      }
    } else {
      return mathLink({
        url: href,
        clazz,
        data: finalData,
        children,
        ensureMath: opts.info.ensureMath,
        noLink: opts.noLink,
      });
    }
  } else {
    if (opts.noLink) {
      return <exps x={children} />;
    } else {
      return (
        <IdA
          clazz={clazz}
          data={finalData}
          name={opts.name}
          children={children}
          replacementId={opts.replacementId}
          forceHref={opts.info.href}
        />
      );
    }
  }
}

function mathLink(
  { clazz, data, url, children, ensureMath, noLink }: {
    url: Expression;
    clazz?: Expression[] | Expression;
    data?: Record<string, Expression>;
    children?: Expressions;
    ensureMath?: boolean;
    noLink?: boolean;
  },
): Expression {
  if (noLink) {
    return ensureMath
      ? (
        <M>
          <exps x={children} />
        </M>
      )
      : <exps x={children} />;
  }

  let exp = <MHref url={url} children={children} />;
  exp = data === undefined ? exp : <MData data={data}>{exp}</MData>;
  exp = clazz === undefined ? exp : <MClass clazz={clazz}>{exp}</MClass>;
  exp = ensureMath ? <M>{exp}</M> : exp;
  return exp;
}

function addDataAttributes(
  ctx: Context,
  data: Record<string, Expression>,
  name: string,
  includeRef: boolean,
  includeAnchor: boolean,
  noHighlight: boolean,
  queryParams: [string, string][],
  replacementId?: string,
  extraData: Record<string, Expression> = {},
) {
  if (includeRef) {
    data.ref = name;
  }

  if (includeAnchor) {
    const previewPath = getPreviewPath(ctx);

    let finalComponent = `${name}.html?def§${
      replacementId === undefined ? name : replacementId
    }`;
    for (const [key, value] of queryParams) {
      finalComponent = `${finalComponent}&${key}§${value}`;
    }

    previewPath.push(finalComponent);

    data["preview-anchor"] = (
      <impure
        fun={(ctx) => {
          return hrefTo(ctx, absoluteOutFsPath(previewPath));
        }}
      />
    );
  }

  if (noHighlight) {
    data["hl"] = "true";
  }

  for (const key in extraData) {
    data[key] = extraData[key];
  }
}
